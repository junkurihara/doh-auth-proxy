use crate::{error::*, AuthenticationConfig};
use jwt_simple::{
  prelude::*,
  token::{Token, TokenMetadata},
};
use serde::Deserialize;
use std::str::FromStr;

#[derive(Debug)]
pub(crate) enum Algorithm {
  ES256,
}
impl FromStr for Algorithm {
  type Err = DapError;
  fn from_str(s: &str) -> Result<Self> {
    match s {
      "ES256" => Ok(Algorithm::ES256),
      _ => Err(DapError::Other(anyhow!("Invalid Algorithm Name"))),
    }
  }
}

#[derive(Debug, Clone)]
pub enum VerificationKeyType {
  ES256(ES256PublicKey),
}

#[derive(Deserialize, Debug, Clone)]
pub struct TokenInner {
  /// id_token jwt itself is given here as string
  pub id: String,
  /// refresh token if required
  pub refresh: Option<String>,
  /// issued at in unix time
  pub issued_at: String,
  /// expires in unix time
  pub expires: String,
  /// allowed apps, i.e, client_ids
  pub allowed_apps: Vec<String>,
  /// issuer specified by url like 'https://example.com/' for IdToken
  pub issuer: String,
  /// subscriber id generated by the token server
  pub subscriber_id: String,
}

#[derive(Deserialize, Debug, Clone)]
pub struct TokenMeta {
  pub username: String,
  pub is_admin: bool,
}

impl TokenInner {
  /// Decode id token and retrieve metadata
  pub async fn decode_id_token(&self) -> Result<TokenMetadata> {
    Token::decode_metadata(&self.id).map_err(|e| DapError::TokenError(e.to_string()))
  }

  /// Verify id token with key string
  pub async fn verify_id_token(
    &self,
    validation_key: &VerificationKeyType,
    config: &AuthenticationConfig,
  ) -> Result<JWTClaims<NoCustomClaims>> {
    let meta = self.decode_id_token().await?;

    let options = VerificationOptions {
      accept_future: true, // accept future
      allowed_audiences: Some(HashSet::from_strings(&[&config.client_id])),
      allowed_issuers: Some(HashSet::from_strings(&[&config.token_api])),
      ..Default::default()
    };

    let clm: JWTClaims<NoCustomClaims> = match Algorithm::from_str(meta.algorithm())? {
      Algorithm::ES256 => {
        let VerificationKeyType::ES256(key) = validation_key else {
          return Err(DapError::AuthenticationError(
            "validation key is inconsistent!".to_string(),
          ));
        };
        key.verify_token::<NoCustomClaims>(&self.id, Some(options))?
      }
    };

    //TODO: Ed25519!

    Ok(clm)
  }
  // pub async fn id_token_expires_in_secs(&self) -> Result<i64> {
  //   // This returns unix time in secs
  //   let clm = self.verify_id_token().await?;
  //   let expires_at: i64 = clm.expires_at.unwrap().as_secs() as i64;
  //   let dt: DateTime<Local> = Local::now();
  //   let timestamp = dt.timestamp();
  //   let expires_in_secs = expires_at - timestamp;
  //   if expires_in_secs < CREDENTIAL_REFRESH_MARGIN {
  //     // try to refresh immediately
  //     return Ok(0);
  //   }

  //   Ok(expires_in_secs)
  // }
}
